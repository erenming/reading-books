# 锁

- 锁机制用于管理对共享资源的并发访问，提供数据的完整性和一致性
- InnoDB存储引擎中的锁
    1. 锁的类型
        - 共享锁（S Lock），允许事务读一行数据
        - 排它锁（X Lock），允许事务删除或更新一行数据
        ![xx](https://raw.githubusercontent.com/erenming/reading-books/master/inside-mysql/images/WX20190506-223543@2x.png)
        - 意向锁(Intention Lock): 可将锁定的对象分为多个层次，这意味着事务希望在更细粒度上进行加锁
    2. 一致性非锁定读(consistent nonblocking read): 通过行多版本控制的方式来读取当前执行时间数据库中行的数据
        - 如果读取的行正在执行DELETE和UPDATE操作，这时读取操作不会因此去等待行上锁的释放，相反去读取行的一个快照
        - 一个行记录可能有不止一个快照数据，一般称为行多版本技术。带来的并发控制称为多版本并发控制(Multi Version Concurrency Control, MVCC)
        - 下述事务隔离级别使用非锁定的一致性读
            1. `READ COMMITTED`: 对于快照数据，总是读取被锁定行的最新一份快照数据
            2. `REPEATABLE READ`: 对于快照数据，总是读取事务开始时的行数据版本
    3. 自增长与锁
        - 每个含有自增长值的表都有一个自增长计数器
        - 插入操作会依据这个计数器加1赋予自增长列，该方式称为`AUTO-INC Locking`
    4. 外键与锁
        - 对于一个外键列，如果没有显式地对这个列加索引，InnoDB存储引擎自动对其加一个索引
- 锁的算法
    1. Record Lock: 单个行记录上的锁
        - 总是会去锁住索引记录，若无索引则隐式使用主键来锁定
    2. Gap Lock: 间隙锁，锁定一个范围，但不包括记录本身
    3. Next-Key Lock: Gap Lock + Record Lock, 锁定一个范围，并且锁定记录本身
        - 用于解决`Phantom Problem`，左开右闭
    4. 解决`Phantom Problem`（幻象问题）
        - 指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行
        ![xx](https://raw.githubusercontent.com/erenming/reading-books/master/inside-mysql/images/WX20190508-165322@2x.png)
        - InnoDB采用`Next-Key Lock`的算法来避免`Phantom Problem`, 对于上述SQL `SELECT * FROM t WHERE a > 2 FOR UPDATE`, 锁住的不是5这个单值，而是对`(2, 正无穷)`这个范围加锁
- 锁问题：锁提高了并发，但是却会带来潜在的问题
    1. 脏读(Dirty Read)
        - 脏数据：事务中对缓冲池中行记录的修改，并且还没有被提交。不同于脏页（未来得及刷入磁盘的）
        - 脏读：在不同的事务下，当前事务可以读到另外事务未提交的数据，简单来说就是可以读到脏数据
        - 看似无用，在某些情况下可设置隔离级别为`READ UNCOMMITED`。例如`slave`节点上，且查询并不需要特别精确的返回值
        - 违反了事务的隔离性
    2. 不可重复读：一个事务中内对次读取同一个数据集合
        - 在这个事务还没有结束时，另外一个事务也访问该同一数据集合，并做了一些`DML`操作
        - 因此，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据就可能不一样
        - 与脏读的区别：脏读是读到的未提交的数据，而不可重复读读到的却是已经提交的
        - 违反了事务的一致性
        - MySQL将不可重复读的问题定义为`Phantom Problem`
    3. 丢失更新：一个事务的更新操作会被另一个事务的更新操作覆盖
        - 数据库能阻止丢失更新的发生
        - 逻辑意义上的会有丢失更新发生，例如银行转账例子
            1. 事务T1查询一行记录，放入本地内存，并显示给一个终端用户User1
            2. 事务T2也查询改行数据，并将取得的数据显示给终端用户User2
            3. User1修改这行记录，更新数据库并提交
            4. User2修改这行记录，更新数据库并提交
        - 此时，可以通过给用户读取记录加上一个排他X锁，从而避免逻辑上的丢失更新
- 阻塞
    1. 因为不同锁之间的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源
- 死锁
    1. 死锁：指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象
    2. 解决方案：
        - 将任何等待都转化为回滚。当然这样性能极差
        - 设置超时
        - `wait-for graph`(等待图)，通过`锁的信息链表`和`事务等待链表`构造出一张图，若这张图存在回路，就代表死锁
            1. 回路检测采用深度优先实现
    3. 死锁的概率：非常小
        - 事务数量(n)，越多发生死锁的概率越大
        - 每个事务操作的数量(r)，越多发生死锁的概率越大
        - 操作数据的集合(R)，越小发生死锁的概率越大
    4. 死锁的示例
        - `AB-BA`死锁: A等待B，B等待A
        ![xx](https://raw.githubusercontent.com/erenming/reading-books/master/inside-mysql/images/WX20190509-162449@2x.png)
        - 当前事务持有了待插入记录的下一个记录的X锁，但是在等待队列中存在一个S锁的请求，则可能发生死锁